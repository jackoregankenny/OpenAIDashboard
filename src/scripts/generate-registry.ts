#!/usr/bin/env node

import { promises as fs } from 'fs';
import path from 'path';
import { glob } from 'glob';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const COMPONENTS_BASE = path.join(process.cwd(), 'src/components/widgets');
const OUTPUT_DIR = path.join(process.cwd(), 'src/lib/registry');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'generated.ts');

/**
 * Converts kebab-case to PascalCase
 * @example 'hero-basic' -> 'HeroBasic'
 */
function toPascalCase(str: string): string {
  return str
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

/**
 * Generate the component registry file
 */
async function generateRegistry() {
  try {
    console.log('üîç Scanning for widget components...\n');

    // Find all widget.config.ts files
    const configFiles = await glob('**/widget.config.ts', {
      cwd: COMPONENTS_BASE,
      absolute: false,
    });

    if (configFiles.length === 0) {
      console.log('‚ö†Ô∏è  No widget components found.');
      console.log('   Create a component in src/components/widgets/[name]/');
      await writeEmptyRegistry();
      return;
    }

    const imports: string[] = [];
    const entries: string[] = [];
    const typeChecks: string[] = [];

    for (const configFile of configFiles) {
      const dir = path.dirname(configFile);
      const componentName = path.basename(dir);

      // Check if index.tsx exists
      const componentPath = path.join(COMPONENTS_BASE, dir, 'index.tsx');
      try {
        await fs.access(componentPath);
      } catch {
        console.log(`‚ö†Ô∏è  Skipping ${componentName}: missing index.tsx`);
        continue;
      }

      // Generate PascalCase name for imports
      const importName = toPascalCase(componentName);

      // Build import paths
      const importPath = `@/components/widgets/${dir.replace(/\\/g, '/')}`;
      const configImportPath = `${importPath}/widget.config`;

      // Add imports
      imports.push(
        `import ${importName}Component from '${importPath}';`,
        `import { widgetConfig as ${importName}Config } from '${configImportPath}';`
      );

      // Add type validation (ensures config matches schema at build time)
      typeChecks.push(
        `// Type check for ${componentName}`,
        `const _check${importName}: WidgetConfig = ${importName}Config;`
      );

      // Add registry entry
      entries.push(
        `  '${componentName}': {`,
        `    config: ${importName}Config,`,
        `    component: ${importName}Component,`,
        `  },`
      );

      console.log(`‚úì Registered: ${componentName}`);
    }

    // Generate the complete registry file
    const output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is auto-generated by scripts/generate-registry.ts
 * Generated: ${new Date().toISOString()}
 * Components found: ${configFiles.length}
 *
 * To regenerate: npm run generate:registry
 */

${imports.join('\n')}

import type { WidgetRegistry, WidgetConfig } from './types';

// Build-time type validation
${typeChecks.join('\n')}

export const widgetRegistry = {
${entries.join('\n')}
} as const satisfies WidgetRegistry;

/**
 * Get a widget by ID with full type safety
 */
export function getWidget<T extends keyof typeof widgetRegistry>(
  id: T
): typeof widgetRegistry[T] | undefined {
  return widgetRegistry[id];
}

/**
 * Get all registered widgets
 */
export function getAllWidgets() {
  return Object.values(widgetRegistry);
}

/**
 * Get widgets filtered by category
 */
export function getWidgetsByCategory(category: string) {
  return Object.values(widgetRegistry).filter(
    (w) => w.config.category === category
  );
}

/**
 * Get all widget IDs
 */
export function getWidgetIds() {
  return Object.keys(widgetRegistry) as Array<keyof typeof widgetRegistry>;
}

/**
 * Type-safe widget ID
 */
export type WidgetId = keyof typeof widgetRegistry;

/**
 * Check if a string is a valid widget ID
 */
export function isValidWidgetId(id: string): id is WidgetId {
  return id in widgetRegistry;
}
`;

    // Ensure output directory exists
    await fs.mkdir(OUTPUT_DIR, { recursive: true });

    // Write the generated file
    await fs.writeFile(OUTPUT_FILE, output, 'utf-8');

    console.log(`\n‚úÖ Generated registry with ${configFiles.length} widget(s)`);
    console.log(`   Output: ${path.relative(process.cwd(), OUTPUT_FILE)}`);
  } catch (error) {
    console.error('‚ùå Failed to generate registry:', error);
    process.exit(1);
  }
}

/**
 * Write an empty registry when no components exist
 */
async function writeEmptyRegistry() {
  const output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is auto-generated by scripts/generate-registry.ts
 * Generated: ${new Date().toISOString()}
 * Components found: 0
 */

import type { WidgetRegistry } from './types';

export const widgetRegistry = {} as const satisfies WidgetRegistry;

export function getWidget(id: string) {
  return undefined;
}

export function getAllWidgets() {
  return [];
}

export function getWidgetsByCategory(category: string) {
  return [];
}

export function getWidgetIds() {
  return [];
}

export type WidgetId = never;

export function isValidWidgetId(id: string): id is WidgetId {
  return false;
}
`;

  await fs.mkdir(OUTPUT_DIR, { recursive: true });
  await fs.writeFile(OUTPUT_FILE, output, 'utf-8');
}

// Run the generator
generateRegistry();
